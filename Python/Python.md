# Python 문법 1일차

## 0. 프로그래밍이란?
- 프로그램
문제를 해결하기 위한 명령어의 집합
우리 집에 오는 방법 -> xx 정류장에 내려 두블럭 직진 후 우회전 처럼 순서를 가진 지시사항을 주는 것.

- 프로그래밍 
새 연산을 정의하고 조합해 유용한 작업을 수행하는것. 즉 위에 프로그램을 만드는 과정.

### 0.1 프로그래밍 언어
컴퓨터에게 작업을 지시 하고 문제를 해결하는 도구. 말을 바로 알아듣지 못하기 때문에 약속한 언어를 내가 배워서 전달해야함. 

### 0.2 Python을 왜 배우냐
- 쉽고 간결한 문법
- 커뮤니티 지원
- 광범위한 응용 분야
### 인공지능에 기본 언어가 Python이다.
Pytorch(Meta), TensorFlow(Google)이 만든 라이브러리가 파이썬으로 제공됨

## 1. 이론
### 1.1 표현식(Expression)
- 하나의 값으로 평가될 수 있는 모든 코드
- 예시
    - 3 + 5
    - x > 5
    - 5 x 4

### 1.2 값(value)
- 표현식이 평가 된 결과
- 더 이상 계산되거나 평가될 수 없는 프로그램의 가장 기본적인 데이터 조각
- 예시
    - 숫자 값: 103.5
    - 문자열 값: "hello
    - 불리언: True, False

### 1.3 변수와 메모리
- 변수(Variable)
값을 나중에 **다시 사용**하기 위해, 그 값에 붙여주는 고유한 이름
- 변수 할당(Variable Assignment)
표현식이 만들어 낸 값에 이름을 붙이는 **과정**
- 할당문 (Assignment Statement)
어떤 값 3.6을 변수 d 에 할당한다.
```python
d = 3.6

d: 변수 이름
= 할당 **연산자**. 오른쪽 표현식의 결과 값을 왼쪽에 저장
변수명은 우리가 외우기 힘든 메모리 주소를 외우기 싫어서 사람을 위해 지정하는것. 
3.6: 표현식
```
- 변수명 규칙
    - 알파벳, 언더스코어, 숫자
    - 숫자로 시작x
    - 대소문자 구분함
    - 내부 예약어와 중복 허용 x
### 1.4 변수, 값 그리고 메모리
컴퓨터에는 메모리가 존재함.  
메모리 모든 위치에는 당연히 주소가 존재
- 객체의 구성
    - 고유한 ID(메모리 주소)
    - 타입
    - 값
    - 값 + 타입 + 주소정보를 묶은것을 객체라고 부름  
    
결국 이 객체를 가리키는 이름표가 바로 **변수**
**변수**는 메모리 주소를 가지지 않는다.
### 1.5 재할당
- 변수는 특정 값을 기억하거나 가리키는 이름일 뿐
- 재할당은 이 변수가 가리키는 대상을 새로운 값으로 변경하는 행위
- 재할당이 이루어지면, 변수는 이전 값을 완전히 잊고 새로운 값만 기억
```python
num = 10
double = 2 * 10
print(double)

num = 5
print(double)
-> 하면 20 출력됨.
```

## 2. Data Type
### 2.1 타입
- 변수나 값이 가질 수 있는 데이터의 종류를 의미
### 2.2 타입의 구성 요소
- 연산자(+,- 등의 연산기호) + 피연산자(숫자, 문자 등)로 구성
### 2.3 Data Type
- 값의 종류와 그 값으로 할 수 있는 데이터의 종류
- 필요한 이유
    - 각 타입에 따라 가능한 연산이 다르기 때문.
        - 숫자는 더하기
        - 문자는 결합
        - 숫자와 문자는 못더함
    이러한 내용들을 명시적으로 적기 위해 Data Type이 필요함.
### 2.4 데이터 타입의 5가지 분류
- Numeric Type
프로그래밍에서 값을 계산하는 등 가장 기본
    - int 정수: 소숫점이 없는 숫자 (양수, 음수, 0)
    - float 실수: 소숫점이 있는 더 정밀한 숫자
    - 지수 표현법 - 아주 크거나 작은 실수를 간결하게 표현하는 방법
        - e 또는 E를 사용
        ```python
        # 1,230,000,000
        big_number = 1.23e9
        # 0.00314(3.14 * 10^-3)
        # small_number = 3.14e-3
        ```
### 2.5 숫자형의 '행동': 산술 연산
- 숫자형의 행동은 계산이 목표
- 이 행동을 지시하는게 산술 연산자
- 연산자 우선순위
    - 지수연산이 항상 우선
    - 음수부호
    - 곱, 나눗, 정수, 나머지
    - 덧뺄셈
    - 햇갈릴 수 있으니 소괄호 적극적으로 쓰면 편함.
    ```python
    print(-2 ** 4) # -16 지수연산자가 우선순위라서 2 ** 4가 먼저 계산된 후에 음수부호 붙음
    print(-(2 ** 4)) # -16
    print((-2) ** 4) # 16
    ```
## 3 Sequence Type
- 여러 개의 값들을 순서대로 나열하여 저장하는 자료형
- Sequense: 여러 데이터가 정해진 순서대로 일렬로 늘어선 자료 구조
- 대표적인 시퀀스: str, list, tuple, range
- index: 자료형에서 각 값의 위치를 식별키 위해 부여된 고유번호
### 3.1 Sequence Type의 5가지 공통특징
1. Order
2. indexing
3. slicing
4. length
5. iteration  
```python
my_data = 'Hello'
```
| 특징 | 사용 예시 | 결과 |
|-------|-------|-------|
| 인덱싱 | my_data[1] | 'e' |
| 슬라이싱 | my_data[1:4] | 'ell' |
| 길이 | len(my_data) | 5 |
| 반복 | for i in my_data | H, e, l, l, o가 순서대로 출력 |

### 3.2 문자열(string)
- 문자들의 순서가 있는, 변경 불가능한 시퀸스 자료형
#### 3.2.1 문자열을 만들고 표현하는 법
- 작은따옴표(')나 큰따옴표(")로 감싸서 사용
```python
# Hello world
print('Hello world')
# 아무튼 항상 통일성있게 "" 던 ''를 하나로 사용할 것.
```
만약 문자열 안에 ', "를 넣고 싶다면?
- 이스케이프 시퀀스를 사용해서 문자열 만들기
```python
print('He\'s a boy') # -> He's a boy 로 출력
```
| 예약 문자 | 기능 |
|-------|-------|
| \n | 줄바꿈 |
| \t | 탭 |
| \t | 백슬래쉬 |
| \\' | 작은 따옴표 |
| \\" | 큰 따옴표 |

- f-string 을 이용한 문자열 만들기
```python
names = [홍길동, 차두리, 정성룡, 기성용]
age =[1,4,2,5]

for i in range(len(names)):
    print(f"내 이름은{name[i]} 이고, 나이는 {age[i]}살이다")
```
- f-string 은 이외에 다양한 기능 제공하니 추가로 심화학습법 til 해봐라.
#### 3.2.2 시퀀스로서의 문자열 활용

| 특징 | 사용 예시 | 결과 | 설명 |
|-------|-------|-------|-------|
| **인덱싱** | my_data[1] | 'e' | 1번 위치의 글자 선택 |
| 슬라이싱 | my_data[1:4] | 'ell' | 1,4번 앞까지 부분 추출 |
| 길이 | len(my_data) | 5 | 문자열의 전체길이 |
| 반복 | for i in my_data | H, e, l, l, o가 순서대로 출력 | 각 문자를 순서대로 처리 |

- 인덱스는 왜 항상 0부터?
    - 컴퓨터 과학에서 거리 개념으로 시작해서 그럼. 인덱스는 결국 메모리 가장 앞 인덱스 주소가 해당 시퀀스 변수의 참조값으로 사용되는 경우가 대부분인데, 그 자체를 바로 호출하려면 0으로 호출
- 파이썬은 음수 인덱싱을 지원함

| | h | e | l | l | o |
|-------|-------|-------|-------|-------|-------|
| + | 0 | 1 | 2 | 3 | 4 |
| - | -5 | -4 | -3 | -2 | -1 |

- 슬라이싱
시퀀스의 일부를 잘라내 새로운 시퀀스를 만드는 작업

```python
sequence[start:stop:step]
# start: 슬라이싱을 시작할 인덱스(포함)
# stop: 끝낼 인덱스(불포함)
# step: 간격

# 슬라이싱 예시
word = "hello"
for i in word:
    print(i) # h, e, l, l, o 가 순서대로 나옴.
# 기본사용
my_str = word[2:4] # -> ll 만 값에 저장됨.
# start를 생략
my_str = word[:3] #-> [0:3]과 같은 의미 hel
# end stop 생략
my_str = word[3:] #-> lo 가 저장
# step만
my_str = word[::2] # ->0, 2, 4만 저장 hlo
# 음수 인덱싱을 이용한 역방향 출력
my_str = word[::-1] # olleh
```
#### 3.2.4 문자열의 불변성
- 문자들의 순서가 있는, 변경 불가능한 시퀀스 자료형(immutabllity)
- 한번 생성된 문자열 객체는 그 내용을 절대 수정할 수 없다.
```python
my_str = "Hello"
my_str[1] = "a"

# 하면 Type 에러가 발생함
# 'str' object does not support item assignment
# 불변하기 때매 저런 에러가 발생.

# 그럼 바꾸려면?
new_str = my_str[0] + "a" + my_str[2:]
print(new_str)
```
- 근데 my_str = "hallo" 해도 되는거 아님? 
    - 아님. 이건 재할당임. 변경과 재할당은 다름.
## 4 정리
### 4.1 정수형의 진법 표현
- 코드 내에서 진법 표현하기

| 진법 | 접두사 | 사용하는 숫/문자|
|-----|-----|-----|
| binary | 0b | 0 1 |
| octal | 0o | 0~7 |
| hexadecimal | 0x | 0~9, a~f |

### 4.2 부동소숫점 오차
- 실수는 계산 결과가 이상하다.
```python
result = 0.1 + 0.2
print(result == 0.3) # -> False 가 나옴. 왜?
print(result) # -> 0.30000000000000004
```
- 컴퓨터는 2진법을 사용해 부동소숫점을 표현한다.
- 이 과정에서 무한소수가 발생할 수 있고, 이를 근사값으로 저장한다.
- 우리가 쓰는 10진수 중 소수 일부(예로 0.1)가 2진수로 바꾸면 무한소수가 된다.
- 그러면 이런 수를 계산하면 메모리 공간이 무한하지 않기 때매 적당히 잘라버리기 때문에 저런 문제가 발생.

```python
a = 3.2 - 3.1
b - 1.2 - 1.1
print(a) # 0.10000000000000009
print(b) # 0.09999999999999987
print(a==b) # False

from decimal import Decimal

a = Decimal('3.2') - Decimal('3.1')
a = Decimal('3.2') - Decimal('3.1')
# 이렇게 적으면 돌아감
```

### 4.3 표현식과 문장
- 문장(Statement): 특정 동작을 지시하는 실행가능한 최소 단위의 코드
    - 할당문, 반복문, 조건문 등 문장이라는 의미를 가짐 하나의 명령 단위
- 표현식 vs 문장 이 햇가린다면? 
    - "이 코드를 실행하면 그래서 **'하나의 값'** 이 남음?
    - 값이 남으면 -> 표현식
        - 10 + 20 -> 값 30이 남음
        - len("hello") -> 값 5가 남음
    - 값이 안남으면? -> 문장

### 4.4 Style Guide
- 코드 가독성과 일관성을 향상시키기 위한 규칙과 권장 사항들
- PEP8 이란 가이드를 따라서 코드를 작성하는게 좋음
- 대표적인 내용
    -  변수명은 무엇을 위한 변수인지 직관적이도록
        - n=0 보단 number_of_student = 0
    - 공백은 4칸, 그냥 탭 써
    - 한 줄의 길이는 79자. 길어지면 줄바꿈
    - 문자와 밑줄(_) 을 써서 함수, 변수, 속성 이름 작성
    - 함수 정의나 클래스 정의 등의 블록 사이에는 빈 줄을 넣어라
### 4.5 주석
- 프로그램 내 설명 넣는거. 프로그램 실행에 아무런 영향을 안줌.
- 단축키
    - ctrl + / 하면 됨.
### python tutor
- 파이썬 코드가 한 줄씩 어떻게 실행되는지 눈으로 보여주는 도구  
[python tutor](https://pythontutor.com)


# 파이썬 문법 2일차
작성일자: 2025-07-22
## 1. List
- 여러 개의 값을 순서대로 저장하는, 변경 가능한(muatble)시퀀스 자료형
- 리스트의 표현
    - 대괄호 [] 안에 값들을 쉼표로 구분
    - 파이썬에서 제공하는 모든 데이터 타입 추가 가능
    - 값을 추가 수정, 삭제 등 자유로움
```python
my_list0 = [] # 빈 리스트, 데이터가 없는
my_list1 = [1, 'a', 3, 6, 'asdf'] # 데이터 섞어서 넣기도 가능
my_list2 = [1,2,3, "python" ["hello",3,4]] # 리스트 안에 리스트도 가능
```
    - 이 때 my_list2 의 길이(len)은 얼마인가? -> 5개. 리스트도 그냥 한개임. 서브리스트
### 1.1 시퀀스로서의 리스트
- 리스트는 시퀀스이므로 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능 모두 사용 가능
```python
my_list = [1,'a',3,'b',5]
# 인덱싱
print(my_list[1]) #a
```
### 1.2 중첩 리스트
- Nested List. 다른 리스트를 값으로 가진 리스트
- 중첩 리스트 값 접근하기
    - 인덱스를 연달아 사용해서 안쪽 값에 접근 가능
    1. 먼저 밖의 리스트의 인덱스로 안쪽 리스트틀 선택
    ```python
    my_list[4] # -> ['hello','world','!!!']]
    ```
    2. 선택된 안쪽 리스트에서 다시 한번 인덱스를 사용
    ```python
    print(my_list[4][-1])  # !!!
    ```
    3. 전체 실습 예시
```python
my_list = [1,2,3,'python',['hello','world','!!!']]
print(my_list(len(my_list)))  # 5
print(my_list[4][-1])  # !!!
print(my_list[-1][1][0])  # w
```
    - 문자열도 시퀀스임을 까먹지 말것.
### 1.3 리스트의 가변성
- 여러 개의 값을 순서대로 저장하는, mutable 시퀀스 자료형임. 변경가능함.
    - 변경 가능하다는 것은 수정, 추가, 삭제 가능하다는 뜻. 문자열의 immutable 과는 반대

### 1.3.1 인덱싱으로 값 수정하기
```python
my_list = [1,2,3,4,5]
my_list[1] = "two"
print(my_list) # [1, "two", 3,4,5]
```
### 1.3.2 슬라이싱으로 여러 값 한번에 수정하기.
```python
my_list = [1,2,3,4,5]
my_list[2:4] = ['three', 'four']
print(my_list)  # [1, 2, 'three', 'four', 5]

# 자른 영역보다 큰 거 넣어도 들어감
my_list = [1,2,3,4,5]
my_list[2:4] = ['three', 'four', 'five']
print(my_list)  # [1, 2, 'three', 'four', 'five', 5] -> 리스트 길이가 6으로 늘어남. 그냥 구간에 우겨넣는거.
```
## 2. Tuple
- 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형(immutable)
- 튜플 표현
    - 소괄호() 쉼표로 구분
    - 모든 종류의 데이터를 담을 수 있음.
    - 리스트랑 거의 비슷하지만, 불변임.
```python
my_tuple = ()
my_tuple2 = (1,) # 요소가 하나일때, 마지막에 쉼표 넣어야함. 후행쉼표. Trailing comma
my_tuple3 = (1,'a',3,'b',5)
my_tuple4 = 1,'hello',3.14159, False # 괄호 안넣어도 생성 가능.
```
### 2.1 시퀀스로서의 튜플
- 튜플 역시 시퀀스이므로, 슬라이싱, 인덱싱, 길이 확인, 반복 가
### 2.2 튜플의 불변성
- 튜플 변경 시도하기
    - 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제 할 수 없음
- 어디에 쓰일까? 왜 불변인가?
    - 개발자가 직접적으로 활용하는 데이터 타입이 아님.
    - 파이썬 내부 동작을 실행할때 사용하는 경우
    - 다중할당, 값 교환 함수 다중 반환 값 등에서 사용. 
```python
#다중 할당
x, y = 10, 20 # 다중할당할때, 내가 하는게 아니라 내부에서 저걸 묶어줌.
# 실제 내부 동작
(x,y) = (10, 20)  # 튜플로 묶여서 할당됨
# -------------------------------
# 값 교환
x,y = 1, 2
x, y = y, x

# 실제 내부 동작
temp = (y,x) # 튜플 생성
x,y = temp # 튜플 언패킹
print(my_tuple[3:])  # (2,1)
```
    - 튜플은 **안전성과 무결성** 을 보장해서 우리가 잘 쓰지는 않지만 내부동작에 사용
        - 리스트는 왜 안씀? 바뀔 수 있기 때문에 내부동작에서 쓰기 무서움.
## 3. range
- **연속된 정수** 시퀀스를 생성하는, immutable 자료형
    - 주로 **반복문**과 함께 사용되어 특정 횟수만큼 코드를 반복할때 매우 유용하게 사용
    - 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙' 만 기억하여 메모리를 매우 효율적으로 사용하게 됨. 
### 3.1 range기본 구문
- range()는 매개변수를 1,2,3개를 가질 수 있음
    - 매개변수는 함수를 정의할 때, 함수가 받는 값을 나타내는 변수
    - 인자는 함수를 호출할때 실제로 전달되는 값.
```python
    range(start, stop, step)
```
- ranage 매개변수별 특징
    - range(stop) # range(0, **in_stop**, 1)
        - 매개변수가 1개면 stop로 인식
        - starts는 0, step는 1로 인식
        - range(5) -> 0, 1, 2, 3, 4
```python
my_range_1 = range(5)
print(my_range_1) -> # range(0,5)가 나오지 0,1,2,3,4 가 나오지 않음
# casting 을 이용해서 리스트로 변환 가능
print(list(my_range_1) # [0, 1, 2, 3, 4]
```
    - range(strat, stop) # range(1, 10)
        - 매개변수가 두개면 strat, stop로 인식, step는 1
        - range(2,5) -> 2, 3, 4
```python
my_range_2 = range(1,10)
print(my_range_2)  # range(1, 10)
print(list(my_range_2))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
    - range(2, 10, 2)
        - 모든 매개변수를 직접 지정
        - range(2, 10, 2) -> 2, 4, 6, 8
```python
my_range_3 = range(2, 10, 2)
print(my_range_3)  # range(2, 10, 2)
print(list(my_range_2))  # [2,4,6,8]
```
### 3.2 range의 규칙
#### 3.2.1 값의 범위 규칙
- stop 값은 생성되는 시퀀스에 절때 포함되지 않음.
    - range(1,5)는 1부터 5**전** 까지 숫자를 의미함으로 1,2,3,4가 생성
- 증가/감소 값(step) 규칙
    - step 값은 숫자 시퀀스의 간격과 방향을 결정함
    - 에러가 발생하진 않음.
```python
# step이 양수일 때 (기본값 1)
# 시작 값이 끝 값보다 작은 경우 (정상)
print(list(range(1, 5)))  # [1, 2, 3, 4]
# 시작 값이 끝 값보다 큰 경우
print(list(range(5, 1)))  # []
-----------------------
# step이 음수일 때
# 시작 값이 끝 값보다 큰 경우 (정상)
print(list(range(5, 1, -1)))  # [5, 4, 3, 2]
# 시작 값이 끝 값보다 작은 경우
print(list(range(1, 5, -1)))  # []
```
- range 활용 예시
    - 주로 반복문 많이 사용
```python
for i in range(1,10):
    print(i) # 1,2,3,4,5,6,7,8,9
for k in range(1,10,2):
    print(i) # 1,3,5,7,9
```
## 4. dict
- key - value쌍으로 이루어진 **순서와 중복**이 없는 변경 가능한 자료형(시퀀스 자료형이 아님, 인덱스가 없음)
- 딕셔너리 표현
    - 중괄호{} 안에 값들이 쉼표로 구분
    - 값 1개는 키와 쌍으로 이루어져 있음
        - key: 값을 식별하기 위한 고유 이름표 **('중복 불가')**
        - value: 키에 해당하는 실제 데이터
        - 인덱스 없음.
```python
my_dict1 = {}
my_dict2 = {"key":"value"}
my_dict3 = {"apple":12, "list":[1,2,3]}
```
    - 딕셔너리는 여전히 순서가 없는 자료형이긴 한데, 파이썬 버전 3.7 이상에서는 입력한 순서는 출력 시 그대로 유지됨. 그래도 핵심은 **순서가 없으며 key를 통한 접근**임. 예전에는 보장안했음.
### 4.1 딕셔너리 규칙
- key의 규칙
    - 고유해야 함. 키는 중복될 수 없음
- immutable 자료형만 가능
    - 가능: str, int, float, tuple
    - 불가능: list, dict
- value 의 규칙
    - 어떤 자료형이던 자유롭게 사용가능
### 4.2 딕셔너리 값 접근
- Key를 사용해 Value를 꺼내 올 수 있음.
- Key에 접근 시 대괄호[]를 사용.
```python
my_dict = {"name":"홍길동", "age":25}
print(my_dict['name']) # 홍길동
print(my_dict['test']) # KeyError 'test'
```
- 딕셔너리 값의 추가 및 변경
```python
my_dict = {"apple":12, "list":[1,2,3]}
# 추가
my_dict['banana'] = 50
print(my_dict) # {"apple":12, "list":[1,2,3], 'banana': 50}
# 변경
my_dict['apple'] = 100
print(my_dict) # {"apple":100, "list":[1,2,3], 'banana': 50}
```
- 딕셔너리를 언제 사용하나?
    - 데이터에 순서가 필요없고, 각 데이터에 의미있는 이름을 붙여서 관리하고 싶을때 사용함
    - 사람의 인적 정보, 게임 캐릭터의 능력치 등
## 5. set
- 순서와 중복이 없는 변경 가능한 자료형
- 세트 표현
    - 중괄호{} 안에 값들을 쉼표로 구분하여 만듬
    - 수학에서의 집합과 동일한 연산 처리 가능
```python
my_set1 = set() # 딕셔너리 빈거 만들땐 중괄호인데, 얘는 소괄호로 빈세트 만듬
my_set2 = {1,2,3}
my_set3 = {1,1,1}
print(my_set1) # set()
print(my_set2) # {1,2,3} # 순서 없음.
print(my_set3) # {1,1,1} 로 초기화 했으나 그냥 하나만 남음. 중복 허용 안함
```
- 세트의 두가지 핵심 특징
    - **중복**을 허용하지 않음
        - 똑같은 값은 단 하나만 사용 가능
    - 순서가 없음
        - 인덱싱이나 슬라이싱을 사용할 수 없음
- 세트도 튜플과 마찬가지로, 개발자가 잘 사용하진 않음. 내부에선 많이 사용.
    - 중복이 없다는 특징을 활용해 집합연산을 사용할 수 있음.
### 5.1 세트 집합 연산
- 수학의 집합개념을 그대로 가져와 두 데이터 그룹간 관례 파악하는데 매우 효과적
```python
my_set_1 = {1,2,3}
my_set_2 = {3,6,9}
# 합집합
print(my_set_1 | my_set_2) # {1,2,3,6,9}
# 차집합
print(my_set_1 - my_sey_2) # {1,2}
# 교집합
print(my_set_! & my_set_2) # {3}
```
- 이런 특성때문에 알고리즘 구현하거나 할때 가끔 씀. 튜플보단 많이 사용함.
## 6. Other Typ
### 6.1 None
- 파이썬에서 데이터 값이 없음을 표현하는 특별한 데이터 타입
    - 빈 상자와 비슷한 개념
    - 숫자 0이나 "" 와는 다른, 값이 없음, 정해지지 않음이란 상태를 나타내기 위해 사용
    - 함수에서 반환 값이 없는데 할당하면 None 뱉음.
```python
# my_varialbe 에 빈 값을 할당하고 싶음
my_variable = None
print(my_variable) # None
```
### 6.2 Boolean
- 참과 거짓 단 두가지 값만 가지는 데이터 타입
    - on/off 스위치처럼 프로그램 흐름을 제어하는 조건문에서 맞다, 틀리다 판단하는 역할
    - 조건문이나 반복문에 같이 활용되는 경우 많음.
```python
is_active = True
is_logged_in = False

print(is_active) # True
print(is_logged_in) # False
print(10>5) # True
print(10==5) # False
```
## 7. Collcetion
- 여러 개의 값을 하나로 묶어서 관리하는 자료형들을 통칭하는 말
- str, list, tuple, range, set, dict 모두 Collection에 분류


| 컬랙션명 | 변경 가능 여부 | 순서 존재 여부 | 시퀀스/비시퀀스 |
|---------|--------------|-------------|------------|
|  str  | X | O | 시퀀스 |
| list | O | O | 시퀀스 |
| tuple | X | O | 시퀀스 |
| dict | O | X | 비시퀀스 |
| set | O | X | 비시퀀스 |

## 8. 불변과 가변
- 불변 vs 가변
    - 컬랙션 타입은 생성 후 변경할 수 있는지와 없는지에 따라 불변과 가변으로 나뉨

| 구분 | immutable | mutable |
|---------|--------------|--------------|
|  특징  | 변경 불가, 안정성, 예측 가능 | 변경 가능, 유연성, 효율성 |
| 종류 | str, tuple, range | list, dict, set |

- 가변 불변 메모리 동작 예
    - 가변예시. list1 = [1,2,3]을 선언하면
        - list1 은 [1,2,3]의 가장 맨 앞 값의 주소를 할당받는다.
        - 그러면 1의 주소를 가지는게 아니라, 인덱스 0번째 주소를 가진다
        - 인덱스 0번째 주소값을 찾아가면 거기에 int type 1이 있다.
    - 불변예시 tuple1 = (1,2)
        - 

```python
# 불변
my_str = "hello"
my_str[0] = "f"
# Type Error: 'str' object does not support item assignment 
# 불변타입이라 변경 못함

# 가변
my_list = [1,2,3]
my_list[0] = 100
print(my_list) # [100,2,3]
```
## 9. 형변환
- Type Conversion. 한 데이터를 다른 데이터타입으로 변환하는 과정
    - 예를 들어 문자열 100을 숫자 100으로 바꾸거나 숫자 3.14를 정수 3으로 바꾸는 등 필요한 형태로 바꿔야 하는 경우에 사용하는 것.
- 두 가지 형변환
    - 암시적 형변환: 파이썬이 알이서
    - 묵시적 형변환: 우리가 하는 것. 개발자가 지시
- 암시적 형변환 Implicit Conversion.
    - 파이썬이 연산 중 자동으로 데이터 타입을 변환하는 것.
    - 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해줌
    - 정수와 실수를 합칠때, 정수도 실수로 변환시켜버림.
```python
print(3 + 5.0) # 8.0 실수로 바꿈
print(True + 3) # 4 True 를 1 로 바꿔 연산
print(True + False) # 1 -> 0 + 1
```
- 명시적 형변환  Explicit Conversion
    - 개발자가 직접 함수로 지정하여 변환하는 것.

| 함수 | 설명 | 예시 | 결과 |
|-----|-----|-----|-----|
| int() | 정수로 변환 | int("123") | 123 |
| float() | 실수로 변환 | float("3.14") | 3.14 |
| str() | 문자열로 변환 | str("123") | "123" |
| list() | 리스트로 변환 | list("123") | ['a','b','c'] |
| tuple() | 튜플로 변환 | tuple([1,2]) | (1,2) |
| set() | 세트로 변환 | set([1,2,2]) | {1,2} |

- 형변환은 형식에 맞는 숫자만 가능
```python
# str -> int 형식에 맞는거만 가능
print(int('1')) # -> 1
print(int('3.5')) # ValueError invalid literal for int() with base 10: '3.5'
print(int(3.5)) # -> 3
print(float('3.5')) # -> 3.5
# int -> str
print(str(1) + '등') # 1등
```
- 컬랙션간 형변환 부딛히면서 몸으로 익힐 필요 있음. 

## 10. 연산자
### 10.1 산술 연산자
| 기호 | 연산자 |
|----|------------|
| -  | 음수 부호 |
| +  | 덧셈 |
| *  | 뺄셈 |
| /  | 곱셈 |
| // | 나눗셈 |
| %  | 정수 나눗셈(몫만)|
| ** | 나머지 |
|    | 지수(거듭제곱)|

### 10.2 복합 연산자
- 연산과 할당이 함께 이루어짐

| 기호 | 예시 | 의미 |
|-----|-----|-----|
| += | a += b | a = a + b |
| -= | a -= b | a = a - b |
| *= | a *= b | a = a * b |
| /= | a /= b | a = a / b |
| //= | a //= b | a = a // b |
| %= | a %= b | a = a % b |
| **= | a **= b | a = a ** b |
```python
y = 10
y -= 4
print(y) # 6
```
### 10.3 비교 연산자
- 두 값을 비교해 결과를 boolen 값으로 return

| 기호 | 예시 |
|-----|-----|
| < | 미만 |
| <= | 이하 |
| > | 초과 |
| >= | 이상 |
| == | 같음 |
| != | 같지 않음 |
| is | 같음 |
| is | not |

- is, == 차이점
- == 연산자(equality)
    - 값이 같은지를 비교
    - 1 == True의 경우 파이썬이 내부적으로 1을 True로 간주해서 True가 나옴
```python
print(2 == 2.0) # True
print(2 != 2) # False
print("Hi" == "hi") # False
print(True == 1) # True. 암시적 형변환을 함.
```
- is 연산자(identity)
    - 객체 자체가 같은지 즉 메모리 주소가 같은지를 물어봄.
    -   객체: 값, 주소가 합쳐진 요소
```python
print(1 == True) # 1이 True와 각은 객체인지를 질문한거라 False나옴.
print(2 is 2.0) # 두 객체의 값과 주소가 같은지 물어보는거라 False

# SyntexWarning "is" with a literal Did you mean ==?
# 너 is 표현식 썼는데 이거 맞냐는 워닝이 뜸.
```
- is 대신 ==를 사용하는 이유
    - 결론: is는 '정체성'을, == 는 가치를 비교하기 때문
    - 두 연산자는 '같다'를 확인하는 목적이 근본적으로 다름
        - is(identity Operation)
            - 두 변수가 완전히 동일한 메모리 주소 객체를 가리키는지, 정체성이 같은지를 확인
        - == (Equality Operation)
            - 두 변수가 가리키는 객체의 내용, 즉 값이 같은지를 확인
    - 대부분의 경우 is를 사용하는 이유가 잘 없음.
- is를 언제 사용하나?
    - singleton 객체를 사용하는 경우에 사용
    - singleton이란 단 하나의 객체만 생성되어 재사용되는 특별한 개체
    - 여러 변수가 이 값을 가져도 모두 미리 만들어둔 하나의 객체를 함께 가리킴
    - 대표적인 싱글톤 객체: None, True, False
    - 여기에 is 쓰면 좋음
```python
x = None
# 권장
if x is None:
    print('x는 None이다')
# 비권장
if x == None:
    print('x는 None이다')
# 비권장 써도 경고 뜨는건 아님. 

x = True
y = True

print(x is y) # True
print(True is True) # True
print(False is False) # True
print(None is None) # True
```
- 추가 예시: 리스트나 객체 비교시 주의 사항
    - 리스트 또는 다른 가변 객체를 비교할때 값이 같은지 확인하려면 ==
    - 두 변수가 동일한 객체를 가리키는지 확인하려면 is 사용
```python
a = [1,2,3]
b = [1,2,3]

print(a == b) # True
print(a is b) # False 

# b 가 a를 그대로 참조하는 경우?
b = a # b에 a의 메모리 주소를 할당한 것. 이거 복사 관련 내용이니 주의해서 생각해야함. 
print(a is b) # True 
```
- is 를 사용하면 골치아파짐. 권장 상황이 아니라면 Equality 쓰는게 편하다.
- == 와 is 장ㄹ;
    - 값 비교에선 ==을 사용하고, 객체 비교에는 is를 쓰는게 원칙
    - 숫자나 문자열 불리언 값 등 동등성 비교에서는 is를 쓰면 의도치 않은 결과가 나올 수 있음.
    - 싱글톤 객체 비교에서 is 사용
### 10.4 논리 연산자
- 여러 개의 조건을 조합하거나 True/False 값을 반대로 뒤집을 때 사용(and, or, not대표적)
```python
# 논리 연산자
print(True and False)  # False
print(True or False)  # True
print(not True)  # False
print(not 0)  # True


# 논리 연산자 & 비교 연산자와 같이 사용
num = 15
result = (num > 10) and (num % 2 == 0)
print(result)  # False

name = 'Alice'
age = 25
result = (name == 'Alice') or (age == 30)
print(result)  # True
```
### 10.5 단축 평가
- 논리 연산에서 두번째 피연산자를 평가하지 않고 결과를 결정하는 동작
- 파이썬의 True, False 에 대한 새로운 시각
    - 단축 평가를 이해하려면 파이썬이 어떤 값을 참, 거짓으로 보는지 알아야 한다.
- 거짓으로 취급되는 값들 
    - False, 숫자0, 빈 문자열"", 빈 리스트[], None 등 비어있거나 없다 느낌의 값들
- 참으로 취급되는 값들
    - True, 그리고 거짓이 아닌 모든 값

- 단축 평가 동작 정리
    - and 연산자
        - 하나라도 거짓이면 바로 거짓
        - and 연산은 왼쪽에서 오른쪽으로 진행하다 처음 만나는 거짓 값을 바로 반환
        - 끝까지 가서 다 참이면 참을 반환
    - or 연산자
        - 하나라도 참이면 바로 참
        - 왼 -> 오 하다 참 만나면 바로 참 반환
        - 끝까지 가서 없으면 거짓 반환
```python
# 1
# 준비물 1: 내용이 있는 문자열
item1 = '지도'
# 준비물 2: 내용이 있는 문자열
item2 = '나침반'
result = item1 and item2
print(f'최종적으로 챙긴 물건: {result}') 
# >> 최종적으로 챙긴 물건: 나침반. 가장 오른쪽에것이 할당됨

# 2
item1 = '지도'
# 준비물 2: 내용이 없는 빈 문자열
item2 = ''
result = item1 and item2
print(f'최종적으로 챙긴 물건: "{result}"')
# >> 최종적으로 챙긴 물건: '' 가 False라서 ''들어감


# 3
# 준비물 1: 내용이 없는 빈 문자열
item1 = ''
item2 = '나침반'
result = item1 and item2
print(f'최종적으로 챙긴 물건: "{result}"')
# >> 최종적으로 챙긴 물건: ''를 먼저 봐서 '' 가 들어감. item2는 보지도 않음.
```
- 단축 평가를 하는 이유
    - 코드 실행 최적화, 불필요한 연산 피함
    - 단순히 False/True연산을 넘어 이처럼 코드 흐름을 제어하고 오류 방지, 간결한 코드 작성에 매우 유용
### 10.6 멤버쉽 연산자
- 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
| 기호 | 내용 |
|-----|-----|
| in | 왼쪽 피연산자가 오른쪽 피연산자 시퀀스에 속하는지 확인 | 
| not in | 왼쪽 피연산자가 오른쪽 피연산자 시퀀스에 속하지 않는지 확인 |
```python
word = 'hello'
numbers = [1, 2, 3, 4, 5]

print('h' in word)  # True
print('z' in word)  # False

print(4 not in numbers)  # False
print(6 not in numbers)  # True
```
### 10.7 시퀀스형 연산자
- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
    - + 는 시퀀스 연결을, * 는 시퀀스를 반복하는 기능

| 연산자 | 내용 |
|-----|-----|
| + | 결합 연산자 | 
| * | 반 연산자 |

```python
print('Gildong' + ' Hong')  # Gildong Hong
print('hi' * 5)  # hihihihihi

print([1, 2] + ['a', 'b'])  # [1, 2, 'a', 'b']
print([1, 2] * 2)  # [1, 2, 1, 2]
```
### 10.8 연산자 우선순위
| 우선순위 | 연산자                     | 내용             |
|----------|----------------------------|------------------|
| 높음     | ()                         | 소괄호 grouping |
|          | []                         | 인덱싱, 슬라이싱 |
|          | **                         | 거듭제곱         |
|          | +, -                       | 단항 연산자 양수/음수 |
|          | *, /, //, %                | 산술 연산자     |
|          | +, -                       | 산술 연산자     |
|          | <, <=, >, >=, ==, !=       | 비교 연산자     |
|          | is, is not                 | 객체 비교       |
|          | in, not in                 | 멤버십 연산자   |
|          | not                        | 논리 부정       |
|          | and                        | 논리 AND        |
| 낮음     | or                         | 논리 OR         |

## 11. 참고자료
### 11.1 Trailing Comma
- 일반적으로 선택사항
- 단 하나의 요소로 구성된 tuple은 필수
```python
# 튜플에선 강제
x = 1 # 정수
x = (1)# 정수
x = 1, # 튜플
x = (1,) # 튜플

# 딕셔너리에서도 많이 사용
items = [
    'item1',
    'item2',
    'item3',
]

config = {
    'host': 'localhost', 
    'port':8080, 
}
# 통상적으로 줄바꿈을 요구함
items = ['items', 'items2',] # <- bad
```
- Trailing Comma 의 장점
    - 가독성 향상
        - 각 줄이 동일 패턴
        - 코드 리뷰 용의
    - 유지보수 용의성
         - 항목 추가 제거 간단
         - 실수로 인한 구문 오류 방지