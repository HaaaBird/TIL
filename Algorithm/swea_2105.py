# swea_2105.py
# 디저트 카페




"""
1. 대각선으로만 움직일 수 있다.
2. 출발한 카페로 돌아와야 한다.
3. 같은 숫자로 방문하면 안된다.
4. 왔던 길을 다시 못돌아간다.


그래프 순회 문제인데... 대각선으로 이동한다 -> 그냥 그래프 그릴 때 방문 가능한 노드로 연결하면 된다.
근데 이게 사각형으로 이동한다는건? 달팽이랑 같은거 아닌가?

델타를 써서 풀어야 한다?
그냥 델타로 순회한다. 달팽이네.

델타를 그린다. 기본적으로 방향을 결정한 변수가 하나 있고,
거리 1~가능한 거리까지 순회를 한다.

일단 4개 방향 모두 길이 1짜리 사각형을 그려보려고 한다.
이동한다 -> ni를 갱신하면서 계속 바꾼다.
while True:
i
1. 그래서 성공하면, 성공한 방향만 남긴다.
2. 거리 2짜리를 그려보려고 한다. 이때, 1번 델타 순회가 거리 2를 채우지 못하고 튕기면, 그 값을 기록했다 3번 순회때 써먹는다.
3. 2번도 마찬가지.


가능한 거리 중단하는 조건은
1. 중간에 겹치는 카페가 있다.
2.

1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C/C++/Java 모두 3초
2. 디저트 카페가 모여있는 지역의 한 변의 길이 N은 4 이상 20 이하의 정수이다. (4 ≤ N ≤ 20)
3. 디저트 종류를 나타나는 수는 1 이상 100 이하의 정수이다.

N이 작다. 그냥 완탐 해도 상관없다. 사실 델타가 중간에 자를꺼라 그냥 대충 해도 된다.
"""

di = [-1, 1, 1, -1] # 북동, 남동, 남서, 북서
dj = [1, 1, -1, -1]
T = int(input())
for case in range(1, T + 1):
    N = int(input())
    matrix = [list(map(int, input().split())) for _ in range(N)]

    # 델타 순회를 한다.
    for i in range(N):
        for j in range(N):
            ni = i
            nj = j
            for f_t in range(N - 1):
                for s_f in range(N - 1):
                    for direction in range(4):
                    pass
            visit = [matrix[i][j]]



    pass
