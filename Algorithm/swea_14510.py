# swea_14510.py
# 나무


"""
N개의 나무가 있다.
초기의 각 나무의 키가 주어진다.
하루에 한 나무에 물을 줄 수 있다.
첫 날은 물을 준 나무의 키가 1 자라고,
둘째 날은 물을 준 나무의 키가 2 자라고,
셋째 날은 물을 준 나무의 키가 1 자라는 식으로,

홀수 번째 날은 키가 1 자라고
짝수 번째 날은 키가 2 자란다.

모든 나무의 키가 처음에 가장 키가 컸던 나무와 같아지도록 할 수 있는 최소 날짜 수를 계산하라.
어떤 날에는 물을 주는 것을 하지 않을 수도 있다.

예를 들어 나무가 2그루이고 각각의 높이가 4와 2라고 하자.
첫째 날에 물을 주게 되면, 나무의 높이를 모두 4로 만들기 위해서는 3일째까지 물을 주어야 한다.
둘째 날은 아무 일도 안 하게 된다. 하지만, 첫째 날을 쉬고 둘째 날에 물을 주면 2일 만에 나무의 높이가 모두 4가 된다.

케이스 수 30, N 제한 100, 나무 높이 최대 120

그 때 푼 대로 풀어보자

무조건 짝수로 만드는 전략

1. 숫자를 전체 순회하면서 홀수와 짝수를 찾는다.
2. 홀수날 홀수를 만나면 홀수, 혹은 답과 거리가 1 남은 나무한테 1을 줘서 짝수로 만든다.
3. 짝숫날 최대 높이보다 2 이상 차이나는 짝수를 만나면 짝수한테 2를 준다.

4. 만약 정답에 도달하면 해당 요소를 빼고 계산한다.
5. 예외 처리 케이스는,

홀수날
남은 나무 모두가 짝수일때 -> 아무나한테 1 준다.
짝수날
남은 나무가 모두 홀수일때 -> 거리가 2 이상인 아무 나무한테 물을 준다.

가장 첫 줄에는 테스트 케이스의 총 수가 주어진다.
그 다음 줄부터 각 테스트 케이스가 주어지며,
각 테스트 케이스는 2줄로 구성된다.
각 테스트 케이스의 첫째 줄에는 나무의 개수 N이 주어진다.
다음 줄에는 나무들의 높이가 N개의 자연수로 주어진다.
"""

T = int(input())
for case in range(1, T + 1):
    N = int(input())
    arr = list(map(int, input().split()))
    max_len = max(arr)

    min_arr = [max_len - arr[i] for i in range(N)]
    all_sum = sum(min_arr)
    base = (all_sum // 3) * 2

    if all_sum - max_len == 2:
        print(f"#{case} 2")
    elif all_sum - max_len == 1:
        print(f"#{case} 1")
    elif all_sum % 3 == 0:
        print(f"#{case} {(all_sum // 3) * 2}")
    else:
        print(f"#{case} {(all_sum // 3) * 2 + 2}")
